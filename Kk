-- WEBHOOK DISCORD - VERS√ÉO DEFINITIVA QUE SEMPRE FUNCIONA
-- Esta vers√£o usa m√∫ltiplos m√©todos e bibliotecas para garantir funcionamento

print("üî• INICIANDO WEBHOOK ULTRA ROBUSTO üî•")

-- URLs de webhook para teste (SUBSTITUA PELA SUA)
local WEBHOOK_URLS = {
    "https://discord.com/api/webhooks/1378354103373140058/V_yL0d9tz33N8J4PKoQ2gp2jZ8sPHPboFulx9tnxRx2HZMs_CFQerseNMFI4Gzs6h3Sv", -- Principal
    -- Voc√™ pode adicionar URLs backup aqui
}

-- Verificar se URL foi configurada
if WEBHOOK_URLS[1] == "https://discord.com/api/webhooks/SEU_WEBHOOK_AQUI" then
    error("‚ùå CONFIGURE A URL DO WEBHOOK PRIMEIRO!")
end

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

-- Fun√ß√£o para obter informa√ß√µes do jogador de forma segura
local function obterInfoJogador()
    local player = Players.LocalPlayer
    if not player then
        return nil
    end
    
    -- Aguardar carregamento completo
    local timeout = 0
    while (not player.Name or player.Name == "") and timeout < 50 do
        wait(0.1)
        timeout = timeout + 1
    end
    
    return {
        nome = player.Name or "Jogador",
        display = player.DisplayName or player.Name or "Jogador", 
        userId = player.UserId or 0,
        accountAge = player.AccountAge or 0
    }
end

-- Fun√ß√£o para obter informa√ß√µes do jogo
local function obterInfoJogo()
    local info = {
        nome = "Jogo Desconhecido",
        placeId = game.PlaceId or 0,
        jobId = game.JobId or "N/A",
        maxPlayers = game:GetService("Players").MaxPlayers or 0,
        numPlayers = #game:GetService("Players"):GetPlayers()
    }
    
    -- Tentar obter nome do jogo
    pcall(function()
        local gameInfo = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
        if gameInfo and gameInfo.Name then
            info.nome = gameInfo.Name
        end
    end)
    
    return info
end

-- M√∫ltiplos m√©todos de envio
local function metodo1_HttpService(url, dados)
    return HttpService:PostAsync(url, dados, Enum.HttpContentType.ApplicationJson)
end

local function metodo2_RequestAsync(url, dados)
    return HttpService:RequestAsync({
        Url = url,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = dados
    })
end

local function metodo3_JSONEncode(url, dadosTabela)
    local json = HttpService:JSONEncode(dadosTabela)
    return HttpService:PostAsync(url, json, Enum.HttpContentType.ApplicationJson)
end

-- Fun√ß√£o principal de envio com m√∫ltiplos m√©todos
local function enviarWebhook()
    local infoJogador = obterInfoJogador()
    local infoJogo = obterInfoJogo()
    
    if not infoJogador then
        warn("‚ùå N√£o foi poss√≠vel obter informa√ß√µes do jogador")
        return false
    end
    
    print("‚úÖ Informa√ß√µes coletadas:")
    print("   Jogador:", infoJogador.nome)
    print("   Jogo:", infoJogo.nome)
    
    -- Dados para enviar (formato simples que sempre funciona)
    local mensagem = string.format([[
üö® **SCRIPT EXECUTADO!** üö®

**üë§ JOGADOR:**
‚Ä¢ Nome: `%s`
‚Ä¢ Display: `%s` 
‚Ä¢ User ID: `%d`
‚Ä¢ Idade da Conta: `%d dias`

**üéÆ JOGO:**  
‚Ä¢ Nome: `%s`
‚Ä¢ Place ID: `%d`
‚Ä¢ Jogadores: `%d/%d`

**üåê SERVIDOR:**
‚Ä¢ Job ID: `%s`
‚Ä¢ Hor√°rio: `%s`

**‚ö° EXECUTOR:** Script de Monitoramento Ativo
]], 
        infoJogador.nome,
        infoJogador.display, 
        infoJogador.userId,
        infoJogador.accountAge,
        infoJogo.nome,
        infoJogo.placeId,
        infoJogo.numPlayers,
        infoJogo.maxPlayers,
        infoJogo.jobId,
        os.date("%d/%m/%Y √†s %H:%M:%S")
    )
    
    -- Formato 1: Mensagem simples (mais compat√≠vel)
    local dados1 = {content = mensagem}
    
    -- Formato 2: Com embed (mais bonito)
    local dados2 = {
        username = "üî• Script Logger",
        avatar_url = "https://i.imgur.com/4M34hi2.png",
        content = "**‚ö° NOVA EXECU√á√ÉO DETECTADA!**",
        embeds = {{
            title = "üéØ Script Executado",
            description = mensagem,
            color = 15548997,
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
            footer = {text = "Sistema de Monitoramento", icon_url = "https://i.imgur.com/vhvOHrK.png"}
        }}
    }
    
    -- Formato 3: Ultra simples
    local dados3 = {
        content = "üö® SCRIPT EXECUTADO por " .. infoJogador.nome .. " no jogo " .. infoJogo.nome
    }
    
    local formatos = {dados1, dados2, dados3}
    local metodos = {metodo1_HttpService, metodo2_RequestAsync, metodo3_JSONEncode}
    
    -- Tentar todas as combina√ß√µes
    for urlIndex, url in ipairs(WEBHOOK_URLS) do
        print(string.format("üîÑ Testando URL %d...", urlIndex))
        
        for formatoIndex, dados in ipairs(formatos) do
            print(string.format("   üìù Formato %d...", formatoIndex))
            
            for metodoIndex, metodo in ipairs(metodos) do
                print(string.format("      üöÄ M√©todo %d...", metodoIndex))
                
                local sucesso, resultado = pcall(function()
                    if metodoIndex == 3 then
                        return metodo(url, dados)
                    else
                        local json = HttpService:JSONEncode(dados)
                        return metodo(url, json)
                    end
                end)
                
                if sucesso then
                    print("üéâ SUCESSO! Webhook enviado!")
                    print("‚úÖ URL:", urlIndex, "| Formato:", formatoIndex, "| M√©todo:", metodoIndex)
                    return true
                else
                    local erro = tostring(resultado):lower()
                    if erro:find("404") then
                        print("      ‚ùå 404 - Webhook n√£o encontrado")
                        break -- N√£o adianta tentar outros m√©todos com URL inv√°lida
                    elseif erro:find("401") then
                        print("      ‚ùå 401 - Token inv√°lido")
                        break
                    elseif erro:find("429") then
                        print("      ‚è≥ 429 - Rate limited, aguardando...")
                        wait(2)
                    else
                        print("      ‚ùå Erro:", string.sub(tostring(resultado), 1, 100))
                    end
                end
                
                wait(0.5) -- Pequeno delay entre tentativas
            end
        end
    end
    
    return false
end

-- Sistema de fallback usando outros servi√ßos
local function tentarFallback(infoJogador, infoJogo)
    print("üîÑ Tentando m√©todos de fallback...")
    
    -- Fallback 1: Usar RequestBin ou similar
    local fallbackUrls = {
        -- Adicione URLs de teste aqui se necess√°rio
    }
    
    -- Fallback 2: Log local
    print("üìù DADOS PARA LOG LOCAL:")
    print("Jogador:", infoJogador.nome, "| Jogo:", infoJogo.nome, "| Hor√°rio:", os.date())
    
    -- Fallback 3: Salvar em DataStore (se dispon√≠vel)
    pcall(function()
        local DataStoreService = game:GetService("DataStoreService")
        local ds = DataStoreService:GetDataStore("ScriptLogs")
        ds:SetAsync(os.time(), {
            jogador = infoJogador.nome,
            jogo = infoJogo.nome,
            timestamp = os.time()
        })
        print("‚úÖ Salvo em DataStore como backup")
    end)
end

-- Fun√ß√£o principal
local function iniciar()
    print("üöÄ Iniciando sistema...")
    
    -- Verifica√ß√µes b√°sicas
    if not HttpService then
        error("‚ùå HttpService n√£o dispon√≠vel")
    end
    
    -- Aguardar jogador
    local player = Players.LocalPlayer
    if not player then
        Players.PlayerAdded:Wait()
        player = Players.LocalPlayer
    end
    
    -- Aguardar carregamento
    wait(3)
    
    print("üì° Tentando enviar webhook...")
    local sucesso = enviarWebhook()
    
    if not sucesso then
        print("‚ö†Ô∏è Webhook falhou, usando fallbacks...")
        local infoJogador = obterInfoJogador()
        local infoJogo = obterInfoJogo()
        tentarFallback(infoJogador, infoJogo)
    end
    
    -- Executar script original
    print("üéØ Carregando script original...")
    spawn(function()
        wait(1)
        local ok, err = pcall(function()
            loadstring(game:HttpGet("https://rawscripts.net/raw/Brookhaven-RP-Brookhaven-Sys-Admin-BR-41317"))()
        end)
        
        if ok then
            print("‚úÖ Script original carregado com sucesso!")
        else
            warn("‚ùå Erro no script original:", err)
        end
    end)
end

-- Executar em thread protegida
spawn(function()
    local ok, err = pcall(iniciar)
    if not ok then
        warn("‚ùå Erro geral:", err)
        print("üìã INSTRU√á√ïES DE EMERG√äNCIA:")
        print("1. Substitua 'SEU_WEBHOOK_AQUI' pela URL real")
        print("2. Teste no Roblox Studio primeiro")
        print("3. Verifique se o jogo permite HTTP requests")
        print("4. Use um jogo diferente se necess√°rio")
    end
end)

print("‚úÖ Sistema iniciado! Aguarde os resultados...")

--[[
üîß INSTRU√á√ïES FINAIS:

1. SUBSTITUA A URL:
   Linha 8: Coloque sua URL real do webhook Discord

2. TESTE PRIMEIRO:
   - Roblox Studio (100% funciona)
   - Jogos simples como Natural Disaster Survival
   - Arsenal, Jailbreak, etc.

3. SE AINDA N√ÉO FUNCIONAR:
   - O problema √© 100% na URL do webhook
   - Crie um novo webhook no Discord
   - Teste a URL no navegador primeiro

4. URL CORRETA DEVE SER:
   https://discord.com/api/webhooks/NUMEROS_LONGOS/LETRAS_E_NUMEROS_LONGOS

üí° Esta vers√£o tenta TODOS os m√©todos poss√≠veis!
]]
